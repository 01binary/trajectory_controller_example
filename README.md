# Integrating Hardware Controllers with MoveIt!

There are a few paths for integrating a controller that moves robot joints with the MoveIt! framework, which accommodate simple usage scenarios all the way to advanced customization:

* Stock controllers [JointTrajectoryController](http://wiki.ros.org/joint_trajectory_controller) and [GripperActionController](http://wiki.ros.org/gripper_action_controller) from [ROS controllers](http://wiki.ros.org/ros_controllers) package are supported out of the box because MoveIt implements integration interfaces and plugins that bridge them with MoveIt motion planning pipeline.
* Any other controllers managed by [ROS Controller Manager](http://wiki.ros.org/controller_manager) can be used by linking them with an existing MoveIt integration plugin, as long as they support [Follow Joint Trajectory Action](https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html).
* Controllers that are managed by [ROS Controller Manager](http://wiki.ros.org/controller_manager) but don't support [Follow Joint Trajectory Action](https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html) can be bridged with MoveIt by implementing integration interfaces and exporting a plugin, as long as they can be made to fit into the [Controller Handle](https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html) interface.
* Custom controllers that are not managed by [ROS Controller Manager](http://wiki.ros.org/controller_manager), or for which the [MoveIt Controller Handle](https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html) is a poor fit, can be integrated by writing a custom MoveIt Controller Manager.

We will look at each of these options in more detail.

## Stock ROS Controllers

The [JointTrajectoryController](http://wiki.ros.org/joint_trajectory_controller) and [GripperActionController](http://wiki.ros.org/gripper_action_controller) from [ROS controllers](http://wiki.ros.org/ros_controllers) package are supported out of the box for simple usage scenarios, and can be easily configured by using the [MoveIt Setup Assistant](https://ros-planning.github.io/moveit_tutorials/doc/setup_assistant/setup_assistant_tutorial.html) (*MSA*) on the *Controllers* page.

These controllers are integrated with MoveIt by using existing [MoveIt Controller Handles](https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html):

* Stock [JointTrajectoryController](http://wiki.ros.org/joint_trajectory_controller) is integrated through [Joint Trajectory Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h).
* Stock [GripperActionController](http://wiki.ros.org/gripper_action_controller) is integrated through [Gripper Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h).

The [ROS Controller Manager](http://wiki.ros.org/controller_manager) loads these controllers from `ros_controllers.yaml` configuration file generated by MSA because they are [exported as plugins](https://github.com/ros-controls/ros_controllers/blob/noetic-devel/joint_trajectory_controller/ros_control_plugins.xml) by the [ROS Controllers](http://wiki.ros.org/ros_controllers) package using their `type` names:

```
arm_controller:
  type: velocity_controllers/JointTrajectoryController
  joints:
    - shoulder_joint
    - upperarm_joint
    - forearm_joint
  gains:
    shoulder_joint:
      p: 100
      d: 1
      i: 1
      i_clamp: 1
    upperarm_joint:
      p: 100
      d: 1
      i: 1
      i_clamp: 1
    forearm_joint:
      p: 100
      d: 1
      i: 1
      i_clamp: 1
gripper_controller:
  type: position_controllers/GripperActionController
  joint: gripper
```

The *MoveIt Simple Controller Manager* configured by MSA [as the default](https://github.com/ros-planning/moveit/blob/master/moveit_setup_assistant/templates/moveit_config_pkg_template/launch/move_group.launch#L17) will load the *handles* that bridge these controllers with MoveIt by reading the `simple_moveit_controllers.yaml` configuration file, for example:

```
controller_list:
  - name: arm_controller
    action_ns: follow_joint_trajectory
    type: FollowJointTrajectory
    default: True
    joints:
      - shoulder_joint
      - upperarm_joint
      - forearm_joint
  - name: gripper_controller
    action_ns: gripper_cmd
    type: GripperCommand
    default: True
    joints:
      - gripper
```

The mapping from ROS controller `name` to MoveIt *controller handle* `type` is done by using pre-defined *simple integration types*:

* `FollowJointTrajectory`: specifying this integration type will bridge the ROS controller specified by the `name` setting to the MoveIt pipeline through the [Joint Trajectory Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h).
* `GripperCommand`: specifying this integration type will bridge the ROS controller specified by the `name` setting to the MoveIt pipeline through the [Gripper Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h).

In both cases, `action_ns` specifies the Action Server name exposed by the ROS controller. The full topic name consists of the ROS controller `name` and the `action_ns`. If you were to list topics by using `rostopic list` with the above two ROS controllers loaded, you would see something like the following:

```
/arm_controller/command
/arm_controller/follow_joint_trajectory/cancel
/arm_controller/follow_joint_trajectory/feedback
/arm_controller/follow_joint_trajectory/goal
/arm_controller/follow_joint_trajectory/result
/arm_controller/follow_joint_trajectory/status
/arm_controller/gains/forearm_joint/parameter_descriptions
/arm_controller/gains/forearm_joint/parameter_updates
/arm_controller/gains/shoulder_joint/parameter_descriptions
/arm_controller/gains/shoulder_joint/parameter_updates
/arm_controller/gains/upperarm_joint/parameter_descriptions
/arm_controller/gains/upperarm_joint/parameter_updates
/arm_controller/state
...
/gripper_controller/gripper_cmd/cancel
/gripper_controller/gripper_cmd/feedback
/gripper_controller/gripper_cmd/goal
/gripper_controller/gripper_cmd/result
/gripper_controller/gripper_cmd/status
...
```

As you can see above, controllers could provide more topics than just the ones used to communicate with MoveIt.

To test simple controller integration with *MoveIt Simple Controller Manager*, launch the package generated by MSA by using the `move_group.launch` file.

This will load your robot description and the MoveIt motion planning pipeline hosted in `move_group` node from `moveit_ros_move_group` package.

> This launch file assumes that your robot's [hardware interface](http://wiki.ros.org/ros_control/Tutorials/Create%20your%20own%20hardware%20interface) is already running, since any ROS controllers you use will attempt to connect to this interface and send commands. It does not not include any [visualization](https://moveit.picknik.ai/main/doc/tutorials/quickstart_in_rviz/quickstart_in_rviz_tutorial.html) and does not [simulate the hardware interface](https://classic.gazebosim.org/tutorials?tut=ros_control&cat=connect_ros). In the absence of visualization and/or simulation tools, you can use the [C++](https://moveit.picknik.ai/main/doc/examples/moveit_cpp/moveitcpp_tutorial.html), [Python](https://moveit.picknik.ai/main/doc/examples/motion_planning_python_api/motion_planning_python_api_tutorial.html), or [Command Line](https://ros-planning.github.io/moveit_tutorials/doc/moveit_commander_scripting/moveit_commander_scripting_tutorial.html) interface to interact with MoveIt.

## ROS Controllers with Joint Trajectory Action

The *MoveIt ROS Control Controller Manager* which is the default configured by MSA for visualizing and/or simulating the robot does not use the configuration in `simple_moveit_controllers.yaml` to discover controllers. Instead it queries [ROS Controller Manager](http://wiki.ros.org/controller_manager) for loaded and active controllers.

Since this discovery process does not use the pre-defined types `FollowJointTrajectory` and `GripperCommand` (only supported by *Simple Controller Manager*), [Controller Handle Allocator](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/include/moveit_ros_control_interface/ControllerHandle.h) plugins also need to be exported for each controller used in this fashion to link ROS controllers to MoveIt *Controller Handles* by their type names.

While [JointTrajectoryController](http://wiki.ros.org/joint_trajectory_controller) from [ROS controllers](http://wiki.ros.org/ros_controllers) is supported by *MoveIt ROS Control Controller Manager* out of the box because its [Controller Handle Allocator](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/joint_trajectory_controller_plugin.cpp) is [exported](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/moveit_ros_control_interface_plugins.xml) as a plugin, the [GripperActionController](http://wiki.ros.org/gripper_action_controller) is not. Even though it has a [Controller Handle](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h), it does not implement or export the corresponding *Controller Handle Allocator* plugin that enables the controller handle to be dynamically created from ROS controller type name. The next few sections will explain how to implement and export such a plugin.

> In the specific case of *Gripper Action Controller*, the corresponding allocator is not exported because this controller is only used with *MoveIt Simple Controller Manager*. It ignores the commanded trajectory and simply sends the last point, thus it can only be used to open or close the gripper given the maximal force and does not provide fine-grained control over the trajectory. Advanced users configure one of the flavors of the Joint Trajectory Controller instead.

Stock *controller handles* implemented by MoveIt bridge ROS Controllers with the MoveIt motion planning pipeline by means of an [Action Client](http://wiki.ros.org/actionlib), as long as the controller starts an *Action Server* that handles one of the two types of supported action interfaces:

* The [Joint Trajectory Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h) plugin can be used for controllers that support [Follow Joint Trajectory Action](https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html).
* The [Gripper Controller Handle](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h) plugin can be used for controllers that support [Gripper Command Action](https://docs.ros.org/en/jade/api/control_msgs/html/action/GripperCommand.html).

The *MoveIt ROS Control Controller Manager* will regard any controllers loaded by ROS Controller Manager as *managed* if it finds a plugin registration that links the `type` of the ROS controller with a MoveIt Controller Handle Allocator. If no such registration is found, the controller is regarded as *unmanaged* (merely *active*) and cannot be used to receive trajectory commands from MoveIt.

For example, see the stock Joint Trajectory Controller [plugin registration](https://github.com/ros-planning/moveit/blob/noetic-devel/moveit_plugins/moveit_ros_control_interface/moveit_ros_control_interface_plugins.xml), which links several flavors of this controller exported from `ros_controllers` package with the corresponding MoveIt Controller Handle that supports [Follow Joint Trajectory Action](https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html) via an exported MoveIt *Controller Handle Allocator* plugin.

The same pattern can be followed to link any other ROS controller with a MoveIt *Controller Handle* so that it can receive trajectory commands.

First, create a plugin description file:

```
<library path="libmoveit_ros_control_interface_trajectory_plugin">
  <class
    name="controller_package_name/controller_type_name"
    type="moveit_ros_control_interface::JointTrajectoryControllerAllocator"
    base_class_type="moveit_ros_control_interface::ControllerHandleAllocator"
  >
    <description>
      Controller description
    </description>
  </class>
</library>
```

> Replace `controller_package_name/controller_type_name` and `Controller description` with values appropriate for your project.

Reference the plugin description in your package `export` section:

```
<export>
  <moveit_ros_control_interface plugin="${prefix}/controller_moveit_plugin.xml"/>
</export>
```

> Replace `/controller_moveit_plugin.xml` with a relative path of the plugin description file created in the previous step.

After building the package, any controllers in `ros_controllers.yaml` that reference `controller_package_name/controller_type_name` will become available for use with MoveIt.

The *MoveIt ROS Control Controller Manager* can be configured by changing the `moveit_controller_manager` setting to `ros_control`. The MoveIt configuration package auto-generated by MSA includes the [demo_gazebo.launch](https://github.com/ros-planning/moveit/blob/master/moveit_setup_assistant/templates/moveit_config_pkg_template/launch/demo_gazebo.launch#L19) file that already configures this manager type in addition to launching [Gazebo](https://classic.gazebosim.org/tutorials?tut=ros_control&cat=connect_ros) simulation and visualizing the robot state in [RViz](https://moveit.picknik.ai/main/doc/tutorials/quickstart_in_rviz/quickstart_in_rviz_tutorial.html).

To test ROS controller integration with *MoveIt ROS Control Controller Manager*, launch the package generated by MSA by using the `demo_gazebo.launch` file. This will load your robot description, start the motion planning pipeline hosted in `move_group` node, and enable you to use the [Motion Planning Plugin](https://ros-planning.github.io/moveit_tutorials/doc/quickstart_in_rviz/quickstart_in_rviz_tutorial.html) in RViz to send goals to MoveIt, simulating the effect your ROS controllers will have on the real robot in Gazebo.

> Since the `GripperActionController` is not supported by MoveIt ROS Control Controller Manager, it can be replaced in the above example by a flavor of `JointTrajectoryController` supported by your hardware, for example:
>```
> gripper_controller:
>  type: position_controllers/JointTrajectoryController
>  joints:
>    - gripper
>```

## ROS Controllers with another interface

What if you need to use a ROS controller that does not support [Follow Joint Trajectory Action](https://docs.ros.org/en/noetic/api/control_msgs/html/action/FollowJointTrajectory.html) with *MoveIt ROS Control Controller Manager*? Some examples from [ROS controllers](http://wiki.ros.org/ros_controllers) package include:

* [Gripper Action Controller](https://github.com/ros-controls/ros_controllers/blob/noetic-devel/gripper_action_controller/ros_control_plugins.xml) discussed earlier
* [Joint Position and Joint Group Position](https://github.com/ros-controls/ros_controllers/blob/noetic-devel/position_controllers/position_controllers_plugins.xml) Controllers
* [Joint Position, Joint Velocity, and Joint Group Velocity](https://github.com/ros-controls/ros_controllers/blob/noetic-devel/velocity_controllers/velocity_controllers_plugins.xml) Controllers
* [Joint Position, Joint Velocity, Joint Effort, Joint Group Effort, and Joint Group Position](https://github.com/ros-controls/ros_controllers/blob/noetic-devel/effort_controllers/effort_controllers_plugins.xml) Controllers

In this case, a *Controller Handle* and a *Controller Handle Allocator* may need to be implemented. The allocator will also need to be exported by your package as a plugin.

The following package dependencies are required for implementing controller handles and allocators:

* `moveit_ros_control_interface` - Provides base classes for controller handles and allocators
* `pluginlib` - Provides macros for exporting a class as a plugin, only needed to export the controller handle allocator

The `actionlib` package may also be needed for communicating with the ROS controller via an *Action Client* if it exposes an *Action Server*.

The following headers declare the relevant classes and macros:

* `#include <moveit_ros_control_interface/ControllerHandle.h>`
  * declares `moveit_controller_manager::MoveItControllerHandle` class
  * declares `moveit_ros_control_interface::ControllerHandleAllocator` class
* `#include <pluginlib/class_list_macros.h>`
  * declares `PLUGINLIB_EXPORT_CLASS` macro for exporting plugins

Two example *controller handle* implementations are included with MoveIt:

* [follow_joint_trajectory_controller_handle.h](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/follow_joint_trajectory_controller_handle.h)
  * See implementation in [follow_joint_trajectory_controller_handle.cpp](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/src/follow_joint_trajectory_controller_handle.cpp)
* [gripper_controller_handle.h](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/include/moveit_simple_controller_manager/gripper_controller_handle.h)
  * Implemented inline in the same header file

As you can see, writing a [controller handle](https://github.com/ros-planning/moveit/blob/master/moveit_core/controller_manager/include/moveit/controller_manager/controller_manager.h#L104) comes down to:
* Implementing a `sendTrajectory` method that translates [moveit_msgs::RobotTrajectory](http://docs.ros.org/en/noetic/api/moveit_msgs/html/msg/RobotTrajectory.html) to a format the controller can understand
* Implementing a `cancelExecution` method to tell the controller to stop any active trajectories
* Implementing a `waitForExecution` method that will block the calling thread until the controller finishes or the `timeout` is reached
* Implementing a `getLastExecutionStatus` method that returns the status of the last requested trajectory.

One example *controller handle allocator* plugin implementation is included with MoveIt:

* [joint_trajectory_controller_plugin.cpp](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/joint_trajectory_controller_plugin.cpp)

The only job of a controller handle allocator is to create a new instance of the controller handle. The following example implements an allocator for a custom controller handle of type `example::controller_handle_example`:

```
#include <moveit_ros_control_interface/ControllerHandle.h>
#include <pluginlib/class_list_macros.h>

namespace example
{
    class controller_handle_allocator_example:
      public moveit_ros_control_interface::ControllerHandleAllocator
    {
    public:
        moveit_controller_manager::MoveItControllerHandlePtr alloc(
          const std::string& name, const std::vector<std::string>& resources)
        {
          return std::make_shared<controller_handle_example>(
            name, std::string("follow_joint_trajectory"));
        }
    };
}

PLUGINLIB_EXPORT_CLASS(
  example::controller_handle_allocator_example,
  moveit_ros_control_interface::ControllerHandleAllocator
)
```

This example controller handle allocator can be exported by creating a plugin definition file which is then referenced in the `exports` section of `package.xml`:

```
<library path="lib/libtrajectory_controller_example">
  <class
    name="example/trajectory_controller_example"
    type="example::controller_handle_allocator_example"
    base_class_type="moveit_ros_control_interface::ControllerHandleAllocator"
  >
    <description>
      Example Controller Handle Allocator for MoveIt!
    </description>
  </class>
</library>
```

> Replace `lib/libtrajectory_controller_example` with your library name by following the same format (prepending `lib/lib` to your library name)

This plugin definition links the name of a controller you are integrating with MoveIt (specified by the `name` attribute) with the type of the allocator you implemented (specified by the `type` attribute), such as the one in the example above.

The `base_class_type` must be set to `moveit_ros_control_interface::ControllerHandleAllocator` to make the allocator discoverable by MoveIt.

The plugin definition can then be referenced in the package manifest:

```
<export>
  <!-- other exports... -->
  <moveit_ros_control_interface plugin="${prefix}/controller_handle_allocator_plugin.xml"/>
</export>
```

The translation between [moveit_msgs::RobotTrajectory](http://docs.ros.org/en/noetic/api/moveit_msgs/html/msg/RobotTrajectory.html) message and the type of command supported by the controller would be done by implementing a controller handle, for example:

```
#include <memory>
#include <moveit_ros_control_interface/ControllerHandle.h>
#include <actionlib/client/simple_action_client.h>

namespace example
{
    class controller_handle_example: public moveit_controller_manager::MoveItControllerHandle
    {
    private:
        // Idle or done executing a trajectory?
        bool done_;

        // Action Client for communicating with target controller
        std::shared_ptr<actionlib::SimpleActionClient<your_controller_action>> actionClient_;

    public:
        controller_handle_example(
          const std::string& name, const std::string& action_ns)
        {
          // Create an Action Client that connects to the controller's Action Server
          std::string actionName = name + "/" + action_ns;

          actionClient_ = std::make_shared<actionlib::SimpleActionClient<your_controller_action>>(
            actionName, true);

          actionClient_->waitForServer(ros::Duration(your_timeout));

          if (!actionClient_->isServerConnected())
          {
            // Report an error
          }
        }

    public:
        // MoveIt calls this method when it wants to send a trajectory goal to execute
        bool sendTrajectory(const moveit_msgs::RobotTrajectory& trajectory) override
        {
          // Translate trajectory to format the controller can understand...
          // Use the Action Client to command the trajectory to the controller...
        }

        // MoveIt calls this method when it wants a blocking call that returns when done
        bool waitForExecution(const ros::Duration& timeout = ros::Duration(0)) override
        {
          if (actionClient_ && !done_)
            return actionClient_->waitForResult(ros::Duration(5.0));

          return true;
        }

        // MoveIt calls this method to get status updates
        moveit_controller_manager::ExecutionStatus getLastExecutionStatus() override
        {
          // Ask the controller through the Action Client about last status
          // Return moveit_controller_manager::ExecutionStatus
        }

        // MoveIt calls this method to abort trajectory goal execution
        bool cancelExecution() override
        {
          // Ask the controller to cancel the goal through the Action Client
        }
    };
}
```

> Replace `your_controller_action` with the type of action interface supported by the controller, and `your_timeout` with how long to wait for the connection to take place (this can be read from settings). If the controller doesn't support an Action Server, this can be replaced by whichever mechanism is supported.

Once implemented, the controller handle does not need to be exported, since it's returned by the controller handle allocator, which is exported.

## Custom Controllers

Custom controllers not managed by ROS Controller Manager can be integrated by implementing MoveIt *Controller Handle* and *Controller Handle Allocator* that conform to the MoveIt interface and can be loaded by MoveIt *Simple* or *ROS Control* Controller Manager as described in the previous section.

If the [Controller Handle](https://docs.ros.org/en/noetic/api/moveit_core/html/classmoveit__controller__manager_1_1MoveItControllerHandle.html) interface is a poor fit for your custom controller, a custom MoveIt Controller Manager can be written that will take care of loading or unloading the controller, and managing its state and lifecycle.

Controller managers implemented and exported by MoveIt framework can be used as examples when implementing a custom controller manager plugin:

* [Test MoveIt Controller Manager](https://github.com/ros-planning/moveit/blob/master/moveit_ros/planning/trajectory_execution_manager/test/test_moveit_controller_manager_plugin.cpp) - a bare bones example of what it takes to implement a MoveIt Controller Manager plugin.
* [MoveIt Fake Controller Manager](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_fake_controller_manager/src/moveit_fake_controller_manager.cpp) - [exported](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_fake_controller_manager/moveit_fake_controller_manager_plugin_description.xml) by `moveit_plugins` package and configured by `demo.launch` file in the MoveIt Config package auto-generated by MSA to preview the effect the chosen controllers would have on the robot by launching RViz with Motion Planning plugin, but without simulating robot hardware. The joints are interpolated from initial to the target state.
* [MoveIt Simple Controller Manager](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/src/moveit_simple_controller_manager.cpp) - [exported](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_simple_controller_manager/moveit_simple_controller_manager_plugin_description.xml) by `moveit_plugins` package. Configured as the default by `move_group.launch` file which is auto-generated by MSA, but can also be used for simulation, visualization, or the real robot.
* [MoveIt ROS Control Controller Manager](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/src/controller_manager_plugin.cpp) - [exported](https://github.com/ros-planning/moveit/blob/master/moveit_plugins/moveit_ros_control_interface/moveit_core_plugins.xml) by `moveit_plugins` package. Discussed in detail in the previous section. Configured by the `demo_gazebo.launch` file which is auto-generated by MSA.
* [MoveIt Multi Controller Manager](https://github.com/ros-planning/moveit/blob/8f39ef78bcae5940f5aad097c3c2fd4a4667b224/moveit_plugins/moveit_ros_control_interface/src/controller_manager_plugin.cpp#L374) - supports multiple running `ros_control` nodes for advanced scenarios. Keeps track of which controller belongs to which node.
